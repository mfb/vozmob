<?php

/* $Id: ffmpeg_wrapper.module,v 1.5 2008/03/21 19:59:59 arthuregg Exp $ */

// This implements a wrapper for FFmpeg so that we don't have to reinvent the 
// the wheel everytime we want to do soemthing with video, audio, or images


/* ************************************************ */
/* DRUPAL HOOKS */
/* ************************************************ */

/**
 * Implementation of hook_menu().
 */
function ffmpeg_wrapper_menu($may_cache) {
  $items = array();
  if ($may_cache) { 
    $items[] = array(
      'path' => 'admin/settings/ffmpeg_wrapper',
      'title' => t('Settings'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('ffmpeg_wrapper_admin'),
      'access' => user_access('administer ffmpeg wrapper'),
    );
  }
  return $items;
}


/**
 * implementation of hook_perm()
 */
function ffmpeg_wrapper_perm() {
  return array('administer ffmpeg wrapper');
}


/**
 * builds the admin form
 * @return drupal form array
 */
function ffmpeg_wrapper_admin() {

  $form['ffmpeg_wrapper'] = array(
    '#type' => 'fieldset',
    '#title' => t('FFmpeg'),
  );

  $form['ffmpeg_wrapper']['mm_ffmpeg_about'] = array(
    '#type' => 'fieldset',
    '#title' => t('About FFmpeg installation'),
    '#collapsible' => true,
    '#collapsed' => true,
  );
  
  $form['ffmpeg_wrapper']['mm_ffmpeg_about']['mm_ffmpeg_version'] = array(
    '#type' => 'item',
    '#title' => t('FFmpeg version'),
    '#value' =>  '<blockquote>'. ffmpeg_wrapper_run_command(' -v') .'</blockquote>',
    '#description' => t('Version of FFmpeg running on your system'),
  ); 
  
  $form['ffmpeg_wrapper']['mm_ffmpeg_about']['mm_ffmpeg_formats'] = array(
    '#type' => 'item',
    '#title' => t('Supported file formats'),
    '#value' =>  ffmpeg_wrapper_formats_data_display(),
    '#description' => t('File formats that the installed version of FFmpeg supports.'),
  ); 
  
  $form['ffmpeg_wrapper']['mm_ffmpeg_about']['mm_ffmpeg_codecs'] = array(
    '#type' => 'item',
    '#title' => t('Installed codecs'),
    '#value' => ffmpeg_wrapper_get_codecs_display(),
    '#description' => t('FFmpeg was either compiled with these codecs, or these are the codecs available on your system'),
  ); 

  $form['ffmpeg_wrapper']['ffmpeg_wrapper_path'] = array(
    '#type' => 'textfield',
    '#title' => t('FFmpeg path'),
    '#default_value' => variable_get('ffmpeg_wrapper_path', '/usr/bin/ffmpeg'),
    '#description' => t("Absolute path to the FFmpeg exeutable."),
  );

  return system_settings_form($form);
}

/* ************************************************ */
/* FFmpeg Wrapper Functions  */
/* ************************************************ */


/**
 * gets data from ffmpeg
 * @param $options are the options to run ffmpeg with
 * @return output of the command
 */
function ffmpeg_wrapper_run_command($options) {
 $command = variable_get('ffmpeg_wrapper_path', '/opt/ffmpeg/current/bin/ffmpeg') .' '. $options; 

 ob_start();
   passthru($command." 2>&1", $command_return );
   $command_output = ob_get_contents();
 ob_end_clean();
 
 return $command_output; 
}



/**
 * checks an incoming file path extension to
 * see if it can be decoded 
 * @param $file is a full system filepath
 * @return true if file is in the list of decodeable files
 */
function ffmpeg_wrapper_can_decode($path){
  $file_types = ffmpeg_wrapper_get_file_formats('decode');
  
  $path_parts = pathinfo($path);
  
  // exception handling  
  // WMVs are sometimes asf files
  if ($path_parts['extension'] == 'wmv') {$exception = 'asf';}
  
  if ($file_types) { 
    foreach ($file_types as $file_type) {
      if ($path_parts['extension']) {
        if (stristr($file_type, $path_parts['extension']) || stristr($file_type, $exception) ) {
          return true;
        } 
      }
    }
  }
  return false;  
}


/**
 * gets an array of codec types usable on this system
 * this should probably be smoothed out so that it doesn't rely on
 * text so much
 * @ TODO this needs to be rethought to pass params right
 * @param string $ret determins hand back of encode/decode
 * @return is array of codecs or specific encode/decode options
 */
function ffmpeg_wrapper_get_codecs($ret = null) { 
  
  // get formats from ffmpeg
  $output =  ffmpeg_wrapper_run_command('-formats');
 
  // parse the list 
  // we know where the codecs are by looking at the output of ffmpeg -formats
  $codecs_formats_pos = strpos($output, "Codecs:");
  $codecs_formats_pos_end = strpos($output, "upported file protocols:");
 
  $video_formats = substr($output, $codecs_formats_pos, ($codecs_formats_pos_end - $codecs_formats_pos));
 
  $video_formats = str_replace('Codecs:', '', $video_formats);
  $video_formats = explode("\n", $video_formats);
 
  foreach ($video_formats as $format) {
   
    // codec names seem to always be here
    $a_format['name'] = substr($format, 8);
    
    if (substr($format, 3, 1) == 'A') {
      $a_format['type'] = t('audio');
      $encode_formats[] = $a_format['name'];
    }
    else {
      $a_format['type'] = t('video');
    }
    
    // get the decode
    if (substr($format, 1, 1) == 'D') {
      $a_format['decode'] = t('yes');
      $decode_formats[] = $a_format['name'];
    }
    else {
      $a_format['decode'] = t('no');       
    }
   
    // get the encode
    if (substr($format, 2, 1) == 'E') {
      $a_format['encode'] = t('yes');
      $encode_formats[] = $a_format['name'];
    }
    else {
      $a_format['encode'] = t('no');          
    }
   
    if ($a_format['name']) {     
      $rows[] = $a_format;
    }
    $a_format = null;    
  }  
  
  switch ($ret) {
    case 'encode':
      return $encode_formats;
    break;
    case 'decode':
      return $decode_formats;
    break;
    default:
      return $rows;
    break;
  } 
}


/**
 * gets an array of format types usable on this system
 * this should probably be smoothed out so that it doesn't rely on
 * text so much
 * @param string $ret determins what to hand back (encode/decode)
 * @return array of options
 */
function ffmpeg_wrapper_get_file_formats($ret = null) { 
  static $rows, $encode_formats, $decode_formats;
 
  // only parse if this hasn't been set 
  if (! is_array($rows)) {
    $formats =  ffmpeg_wrapper_run_command('-formats');

    // slice up the format output
    $startpos = strpos($formats, 'File formats:');
    $endpos = strpos($formats, 'Codecs:');    
    $formats = substr($formats, $startpos, $endpos);
    
    //remove the header
    $formats = str_replace('File formats:', '', $formats);
    
    $formats = explode("\n", $formats);
 
    $decode_formats = array();
    $encode_formats = array();
     
    foreach ($formats as $format) {

      // only run on lines longer than 3
      if (! strlen($format) < 3) {
        // codec names seem to always be here
        $pattern = '/\s+/';
        $replace = ' ';      
        $type = preg_replace($pattern, $replace, substr($format, 4, 19));
        $type = explode(' ', $type);

        $a_format['type'] = $type[0];
        $a_format['name'] = $type[1];
        
        if (substr($format, 1, 1) == 'D') {
          $a_format['decode'] = t('yes');
          $decode_formats[] = $a_format['type'];
        }
        else {
          $a_format['decode'] = t('no');       
        }
       
        if (substr($format, 2, 1) == 'E') {
          $a_format['encode'] = t('yes');
          $encode_formats[] = $a_format['type'];
        }
        else {
          $a_format['encode'] = t('no');          
        }
       
        $a_format['description'] = substr($format, 20);
        if ($a_format['description']) {     
          $rows[] = $a_format;
        }       
      }
    }  
  }

  switch ($ret) {
    case 'encode':
      return $encode_formats;
    break;
    case 'decode':
      return $decode_formats;
    break;
    default:
      return $rows;
    break;
  }
}


/**
 * this gets the duration of a video
 * @param string $path is the path to file
 * @param boolean $timecode return time code or seconds
 * @return int is the duration in seconds or timecode as string
 */
function ffmpeg_wrapper_file_duration($path, $timecode) {
  // get duration from ffmpeg
  $output =  ffmpeg_wrapper_run_command("-i $path");

  // parse the output looking for "Duration: 00:02:12"
  $pattern = "/Duration: (.*[0-9:])(\.*[0-9]), start/";
  preg_match($pattern, $output, $matches);

  $time = $matches[1];
  
  if (! $timecode) { 
    // now we need to convert the time code to seconds
    // get the time into an array, note that the array is hh:mm:ss
    $time = explode(':', $time);
    
    $seconds = $time[2];
    
    if ($time[1] != '00') {
      $seconds = $seconds + ($time[1] * 60);
    }
    if ($time[0] != '00') {
      $seconds = $seconds + ($time[0] * 3600);
    }
    
    $time = $seconds;
  }

  return $time;
}


/**
 * checks to make sure that FFmpeg is in the path
 * @return boolean
 */
function ffmpeg_wrapper_executable(){
  if (! ffmpeg_wrapper_run_command('')) {
    return false;     
  }
  return true;
}


/**
 * displays a table of the supported ffmpeg file formats
 */
function ffmpeg_wrapper_formats_data_display() {
  $header = array(t('name'), t('type'), t('decode'), t('encode'), t('description') );
  $output = theme('table', $header, ffmpeg_wrapper_get_file_formats() );
  return $output;
}


/**
 * displays a table of the ffmpeg encoding and decoding options
 */
function ffmpeg_wrapper_get_codecs_display() {
  $header = array(t('codec'), t('codec type'), t('decode'), t('encode'));
  $output = theme('table', $header, ffmpeg_wrapper_get_codecs() );
  return $output;
}


/**
 * checks ffmpeg's output for errors and tries to handle them some way
 * @param $output is the output from a shell command
 * @param $file is the input file
 * @param $command is the command run
 * @param $watchdog is boolean, log errors to drupal's watchdog
 * @return true if no errors, false if errors
 * 
 **/
function ffmpeg_wrapper_error_check($output, $file, $command, $watchdog = true) {

  // build the error conditions
  // these are all pulled by hand at this point
  $errors = array(
    '/Segmentation fault/i',
    '/Unsupported/i', 
   //'/Error while/i', // this is not necessarily fatal
    '/Unable for find a suitable output format for/i',
    '/Incorrect frame size/i',
    '/Unsupported codec/i',
    '/Could not write header/i',
    '/Incorrect frame size/i',
  );

  // check for error conditions    
  foreach ($errors as $error) { 
    if ($match = preg_match($error, $output)) {
      ffmpeg_wrapper_error_log($output, $file, $command, $watchdog);
      return false;
    }
  }
  return true;
}


/**
 * takes error conditions from the conversion process and deals
 * with them according to the admin configuration
 * 
 * @param $output is the command line output
 * @param $file is the file that failed
 * @param $configuration is the configuration that was running
 * @param boolean $watchdog should we log this?
 */
function ffmpeg_wrapper_error_log($output, $file, $command, $watchdog){
  
  // create an error log
  $message = t('FFmpeg had an error converting this file: %file', array('%file' => $file));
  $message .= '<br />'. t('The command was: ') . $command;
  
  if ($watchdog) {
    watchdog('FFmpeg', $message, 'WATCHDOG_NOTICE');
  }
}

